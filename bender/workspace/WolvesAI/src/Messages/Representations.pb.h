// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Representations.proto

#ifndef PROTOBUF_Representations_2eproto__INCLUDED
#define PROTOBUF_Representations_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
// @@protoc_insertion_point(includes)

namespace protobuf {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_Representations_2eproto();
void protobuf_AssignDesc_Representations_2eproto();
void protobuf_ShutdownFile_Representations_2eproto();

class YUVImage;
class CameraSettings;

// ===================================================================

class YUVImage : public ::google::protobuf::MessageLite {
 public:
  YUVImage();
  virtual ~YUVImage();
  
  YUVImage(const YUVImage& from);
  
  inline YUVImage& operator=(const YUVImage& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const YUVImage& default_instance();
  
  void Swap(YUVImage* other);
  
  // implements Message ----------------------------------------------
  
  YUVImage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const YUVImage& from);
  void MergeFrom(const YUVImage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bytes data = 1;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 1;
  inline const ::std::string& data() const;
  inline void set_data(const ::std::string& value);
  inline void set_data(const char* value);
  inline void set_data(const void* value, size_t size);
  inline ::std::string* mutable_data();
  inline ::std::string* release_data();
  
  // optional int32 width = 2 [default = 320];
  inline bool has_width() const;
  inline void clear_width();
  static const int kWidthFieldNumber = 2;
  inline ::google::protobuf::int32 width() const;
  inline void set_width(::google::protobuf::int32 value);
  
  // optional int32 height = 3 [default = 240];
  inline bool has_height() const;
  inline void clear_height();
  static const int kHeightFieldNumber = 3;
  inline ::google::protobuf::int32 height() const;
  inline void set_height(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:protobuf.YUVImage)
 private:
  inline void set_has_data();
  inline void clear_has_data();
  inline void set_has_width();
  inline void clear_has_width();
  inline void set_has_height();
  inline void clear_has_height();
  
  ::std::string* data_;
  ::google::protobuf::int32 width_;
  ::google::protobuf::int32 height_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_Representations_2eproto();
  friend void protobuf_AssignDesc_Representations_2eproto();
  friend void protobuf_ShutdownFile_Representations_2eproto();
  
  void InitAsDefaultInstance();
  static YUVImage* default_instance_;
};
// -------------------------------------------------------------------

class CameraSettings : public ::google::protobuf::MessageLite {
 public:
  CameraSettings();
  virtual ~CameraSettings();
  
  CameraSettings(const CameraSettings& from);
  
  inline CameraSettings& operator=(const CameraSettings& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const CameraSettings& default_instance();
  
  void Swap(CameraSettings* other);
  
  // implements Message ----------------------------------------------
  
  CameraSettings* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CameraSettings& from);
  void MergeFrom(const CameraSettings& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 width = 1;
  inline bool has_width() const;
  inline void clear_width();
  static const int kWidthFieldNumber = 1;
  inline ::google::protobuf::int32 width() const;
  inline void set_width(::google::protobuf::int32 value);
  
  // required int32 height = 2;
  inline bool has_height() const;
  inline void clear_height();
  static const int kHeightFieldNumber = 2;
  inline ::google::protobuf::int32 height() const;
  inline void set_height(::google::protobuf::int32 value);
  
  // optional int32 frameIntervalNumerator = 3;
  inline bool has_frameintervalnumerator() const;
  inline void clear_frameintervalnumerator();
  static const int kFrameIntervalNumeratorFieldNumber = 3;
  inline ::google::protobuf::int32 frameintervalnumerator() const;
  inline void set_frameintervalnumerator(::google::protobuf::int32 value);
  
  // optional int32 frameIntervalDenominator = 4;
  inline bool has_frameintervaldenominator() const;
  inline void clear_frameintervaldenominator();
  static const int kFrameIntervalDenominatorFieldNumber = 4;
  inline ::google::protobuf::int32 frameintervaldenominator() const;
  inline void set_frameintervaldenominator(::google::protobuf::int32 value);
  
  // optional double brightness = 5;
  inline bool has_brightness() const;
  inline void clear_brightness();
  static const int kBrightnessFieldNumber = 5;
  inline double brightness() const;
  inline void set_brightness(double value);
  
  // optional double contrast = 6;
  inline bool has_contrast() const;
  inline void clear_contrast();
  static const int kContrastFieldNumber = 6;
  inline double contrast() const;
  inline void set_contrast(double value);
  
  // optional double saturation = 7;
  inline bool has_saturation() const;
  inline void clear_saturation();
  static const int kSaturationFieldNumber = 7;
  inline double saturation() const;
  inline void set_saturation(double value);
  
  // optional double autohue = 8;
  inline bool has_autohue() const;
  inline void clear_autohue();
  static const int kAutohueFieldNumber = 8;
  inline double autohue() const;
  inline void set_autohue(double value);
  
  // optional double hue = 9;
  inline bool has_hue() const;
  inline void clear_hue();
  static const int kHueFieldNumber = 9;
  inline double hue() const;
  inline void set_hue(double value);
  
  // optional double autowhitebalance = 10;
  inline bool has_autowhitebalance() const;
  inline void clear_autowhitebalance();
  static const int kAutowhitebalanceFieldNumber = 10;
  inline double autowhitebalance() const;
  inline void set_autowhitebalance(double value);
  
  // optional double redbalance = 11;
  inline bool has_redbalance() const;
  inline void clear_redbalance();
  static const int kRedbalanceFieldNumber = 11;
  inline double redbalance() const;
  inline void set_redbalance(double value);
  
  // optional double bluebalance = 12;
  inline bool has_bluebalance() const;
  inline void clear_bluebalance();
  static const int kBluebalanceFieldNumber = 12;
  inline double bluebalance() const;
  inline void set_bluebalance(double value);
  
  // optional double gamma = 13;
  inline bool has_gamma() const;
  inline void clear_gamma();
  static const int kGammaFieldNumber = 13;
  inline double gamma() const;
  inline void set_gamma(double value);
  
  // optional double exposure = 14;
  inline bool has_exposure() const;
  inline void clear_exposure();
  static const int kExposureFieldNumber = 14;
  inline double exposure() const;
  inline void set_exposure(double value);
  
  // optional double autogain = 15;
  inline bool has_autogain() const;
  inline void clear_autogain();
  static const int kAutogainFieldNumber = 15;
  inline double autogain() const;
  inline void set_autogain(double value);
  
  // optional double gain = 16;
  inline bool has_gain() const;
  inline void clear_gain();
  static const int kGainFieldNumber = 16;
  inline double gain() const;
  inline void set_gain(double value);
  
  // optional double sharpness = 17;
  inline bool has_sharpness() const;
  inline void clear_sharpness();
  static const int kSharpnessFieldNumber = 17;
  inline double sharpness() const;
  inline void set_sharpness(double value);
  
  // optional double powerlinefreq = 18;
  inline bool has_powerlinefreq() const;
  inline void clear_powerlinefreq();
  static const int kPowerlinefreqFieldNumber = 18;
  inline double powerlinefreq() const;
  inline void set_powerlinefreq(double value);
  
  // optional double whitebalancetemp = 19;
  inline bool has_whitebalancetemp() const;
  inline void clear_whitebalancetemp();
  static const int kWhitebalancetempFieldNumber = 19;
  inline double whitebalancetemp() const;
  inline void set_whitebalancetemp(double value);
  
  // optional double backlightcompensation = 20;
  inline bool has_backlightcompensation() const;
  inline void clear_backlightcompensation();
  static const int kBacklightcompensationFieldNumber = 20;
  inline double backlightcompensation() const;
  inline void set_backlightcompensation(double value);
  
  // optional double autoexposure = 21;
  inline bool has_autoexposure() const;
  inline void clear_autoexposure();
  static const int kAutoexposureFieldNumber = 21;
  inline double autoexposure() const;
  inline void set_autoexposure(double value);
  
  // @@protoc_insertion_point(class_scope:protobuf.CameraSettings)
 private:
  inline void set_has_width();
  inline void clear_has_width();
  inline void set_has_height();
  inline void clear_has_height();
  inline void set_has_frameintervalnumerator();
  inline void clear_has_frameintervalnumerator();
  inline void set_has_frameintervaldenominator();
  inline void clear_has_frameintervaldenominator();
  inline void set_has_brightness();
  inline void clear_has_brightness();
  inline void set_has_contrast();
  inline void clear_has_contrast();
  inline void set_has_saturation();
  inline void clear_has_saturation();
  inline void set_has_autohue();
  inline void clear_has_autohue();
  inline void set_has_hue();
  inline void clear_has_hue();
  inline void set_has_autowhitebalance();
  inline void clear_has_autowhitebalance();
  inline void set_has_redbalance();
  inline void clear_has_redbalance();
  inline void set_has_bluebalance();
  inline void clear_has_bluebalance();
  inline void set_has_gamma();
  inline void clear_has_gamma();
  inline void set_has_exposure();
  inline void clear_has_exposure();
  inline void set_has_autogain();
  inline void clear_has_autogain();
  inline void set_has_gain();
  inline void clear_has_gain();
  inline void set_has_sharpness();
  inline void clear_has_sharpness();
  inline void set_has_powerlinefreq();
  inline void clear_has_powerlinefreq();
  inline void set_has_whitebalancetemp();
  inline void clear_has_whitebalancetemp();
  inline void set_has_backlightcompensation();
  inline void clear_has_backlightcompensation();
  inline void set_has_autoexposure();
  inline void clear_has_autoexposure();
  
  ::google::protobuf::int32 width_;
  ::google::protobuf::int32 height_;
  ::google::protobuf::int32 frameintervalnumerator_;
  ::google::protobuf::int32 frameintervaldenominator_;
  double brightness_;
  double contrast_;
  double saturation_;
  double autohue_;
  double hue_;
  double autowhitebalance_;
  double redbalance_;
  double bluebalance_;
  double gamma_;
  double exposure_;
  double autogain_;
  double gain_;
  double sharpness_;
  double powerlinefreq_;
  double whitebalancetemp_;
  double backlightcompensation_;
  double autoexposure_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(21 + 31) / 32];
  
  friend void  protobuf_AddDesc_Representations_2eproto();
  friend void protobuf_AssignDesc_Representations_2eproto();
  friend void protobuf_ShutdownFile_Representations_2eproto();
  
  void InitAsDefaultInstance();
  static CameraSettings* default_instance_;
};
// ===================================================================


// ===================================================================

// YUVImage

// required bytes data = 1;
inline bool YUVImage::has_data() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void YUVImage::set_has_data() {
  _has_bits_[0] |= 0x00000001u;
}
inline void YUVImage::clear_has_data() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void YUVImage::clear_data() {
  if (data_ != &::google::protobuf::internal::kEmptyString) {
    data_->clear();
  }
  clear_has_data();
}
inline const ::std::string& YUVImage::data() const {
  return *data_;
}
inline void YUVImage::set_data(const ::std::string& value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void YUVImage::set_data(const char* value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void YUVImage::set_data(const void* value, size_t size) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* YUVImage::mutable_data() {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  return data_;
}
inline ::std::string* YUVImage::release_data() {
  clear_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = data_;
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 width = 2 [default = 320];
inline bool YUVImage::has_width() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void YUVImage::set_has_width() {
  _has_bits_[0] |= 0x00000002u;
}
inline void YUVImage::clear_has_width() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void YUVImage::clear_width() {
  width_ = 320;
  clear_has_width();
}
inline ::google::protobuf::int32 YUVImage::width() const {
  return width_;
}
inline void YUVImage::set_width(::google::protobuf::int32 value) {
  set_has_width();
  width_ = value;
}

// optional int32 height = 3 [default = 240];
inline bool YUVImage::has_height() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void YUVImage::set_has_height() {
  _has_bits_[0] |= 0x00000004u;
}
inline void YUVImage::clear_has_height() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void YUVImage::clear_height() {
  height_ = 240;
  clear_has_height();
}
inline ::google::protobuf::int32 YUVImage::height() const {
  return height_;
}
inline void YUVImage::set_height(::google::protobuf::int32 value) {
  set_has_height();
  height_ = value;
}

// -------------------------------------------------------------------

// CameraSettings

// required int32 width = 1;
inline bool CameraSettings::has_width() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CameraSettings::set_has_width() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CameraSettings::clear_has_width() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CameraSettings::clear_width() {
  width_ = 0;
  clear_has_width();
}
inline ::google::protobuf::int32 CameraSettings::width() const {
  return width_;
}
inline void CameraSettings::set_width(::google::protobuf::int32 value) {
  set_has_width();
  width_ = value;
}

// required int32 height = 2;
inline bool CameraSettings::has_height() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CameraSettings::set_has_height() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CameraSettings::clear_has_height() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CameraSettings::clear_height() {
  height_ = 0;
  clear_has_height();
}
inline ::google::protobuf::int32 CameraSettings::height() const {
  return height_;
}
inline void CameraSettings::set_height(::google::protobuf::int32 value) {
  set_has_height();
  height_ = value;
}

// optional int32 frameIntervalNumerator = 3;
inline bool CameraSettings::has_frameintervalnumerator() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CameraSettings::set_has_frameintervalnumerator() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CameraSettings::clear_has_frameintervalnumerator() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CameraSettings::clear_frameintervalnumerator() {
  frameintervalnumerator_ = 0;
  clear_has_frameintervalnumerator();
}
inline ::google::protobuf::int32 CameraSettings::frameintervalnumerator() const {
  return frameintervalnumerator_;
}
inline void CameraSettings::set_frameintervalnumerator(::google::protobuf::int32 value) {
  set_has_frameintervalnumerator();
  frameintervalnumerator_ = value;
}

// optional int32 frameIntervalDenominator = 4;
inline bool CameraSettings::has_frameintervaldenominator() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CameraSettings::set_has_frameintervaldenominator() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CameraSettings::clear_has_frameintervaldenominator() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CameraSettings::clear_frameintervaldenominator() {
  frameintervaldenominator_ = 0;
  clear_has_frameintervaldenominator();
}
inline ::google::protobuf::int32 CameraSettings::frameintervaldenominator() const {
  return frameintervaldenominator_;
}
inline void CameraSettings::set_frameintervaldenominator(::google::protobuf::int32 value) {
  set_has_frameintervaldenominator();
  frameintervaldenominator_ = value;
}

// optional double brightness = 5;
inline bool CameraSettings::has_brightness() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CameraSettings::set_has_brightness() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CameraSettings::clear_has_brightness() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CameraSettings::clear_brightness() {
  brightness_ = 0;
  clear_has_brightness();
}
inline double CameraSettings::brightness() const {
  return brightness_;
}
inline void CameraSettings::set_brightness(double value) {
  set_has_brightness();
  brightness_ = value;
}

// optional double contrast = 6;
inline bool CameraSettings::has_contrast() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CameraSettings::set_has_contrast() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CameraSettings::clear_has_contrast() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CameraSettings::clear_contrast() {
  contrast_ = 0;
  clear_has_contrast();
}
inline double CameraSettings::contrast() const {
  return contrast_;
}
inline void CameraSettings::set_contrast(double value) {
  set_has_contrast();
  contrast_ = value;
}

// optional double saturation = 7;
inline bool CameraSettings::has_saturation() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CameraSettings::set_has_saturation() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CameraSettings::clear_has_saturation() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CameraSettings::clear_saturation() {
  saturation_ = 0;
  clear_has_saturation();
}
inline double CameraSettings::saturation() const {
  return saturation_;
}
inline void CameraSettings::set_saturation(double value) {
  set_has_saturation();
  saturation_ = value;
}

// optional double autohue = 8;
inline bool CameraSettings::has_autohue() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CameraSettings::set_has_autohue() {
  _has_bits_[0] |= 0x00000080u;
}
inline void CameraSettings::clear_has_autohue() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void CameraSettings::clear_autohue() {
  autohue_ = 0;
  clear_has_autohue();
}
inline double CameraSettings::autohue() const {
  return autohue_;
}
inline void CameraSettings::set_autohue(double value) {
  set_has_autohue();
  autohue_ = value;
}

// optional double hue = 9;
inline bool CameraSettings::has_hue() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void CameraSettings::set_has_hue() {
  _has_bits_[0] |= 0x00000100u;
}
inline void CameraSettings::clear_has_hue() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void CameraSettings::clear_hue() {
  hue_ = 0;
  clear_has_hue();
}
inline double CameraSettings::hue() const {
  return hue_;
}
inline void CameraSettings::set_hue(double value) {
  set_has_hue();
  hue_ = value;
}

// optional double autowhitebalance = 10;
inline bool CameraSettings::has_autowhitebalance() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void CameraSettings::set_has_autowhitebalance() {
  _has_bits_[0] |= 0x00000200u;
}
inline void CameraSettings::clear_has_autowhitebalance() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void CameraSettings::clear_autowhitebalance() {
  autowhitebalance_ = 0;
  clear_has_autowhitebalance();
}
inline double CameraSettings::autowhitebalance() const {
  return autowhitebalance_;
}
inline void CameraSettings::set_autowhitebalance(double value) {
  set_has_autowhitebalance();
  autowhitebalance_ = value;
}

// optional double redbalance = 11;
inline bool CameraSettings::has_redbalance() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void CameraSettings::set_has_redbalance() {
  _has_bits_[0] |= 0x00000400u;
}
inline void CameraSettings::clear_has_redbalance() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void CameraSettings::clear_redbalance() {
  redbalance_ = 0;
  clear_has_redbalance();
}
inline double CameraSettings::redbalance() const {
  return redbalance_;
}
inline void CameraSettings::set_redbalance(double value) {
  set_has_redbalance();
  redbalance_ = value;
}

// optional double bluebalance = 12;
inline bool CameraSettings::has_bluebalance() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void CameraSettings::set_has_bluebalance() {
  _has_bits_[0] |= 0x00000800u;
}
inline void CameraSettings::clear_has_bluebalance() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void CameraSettings::clear_bluebalance() {
  bluebalance_ = 0;
  clear_has_bluebalance();
}
inline double CameraSettings::bluebalance() const {
  return bluebalance_;
}
inline void CameraSettings::set_bluebalance(double value) {
  set_has_bluebalance();
  bluebalance_ = value;
}

// optional double gamma = 13;
inline bool CameraSettings::has_gamma() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void CameraSettings::set_has_gamma() {
  _has_bits_[0] |= 0x00001000u;
}
inline void CameraSettings::clear_has_gamma() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void CameraSettings::clear_gamma() {
  gamma_ = 0;
  clear_has_gamma();
}
inline double CameraSettings::gamma() const {
  return gamma_;
}
inline void CameraSettings::set_gamma(double value) {
  set_has_gamma();
  gamma_ = value;
}

// optional double exposure = 14;
inline bool CameraSettings::has_exposure() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void CameraSettings::set_has_exposure() {
  _has_bits_[0] |= 0x00002000u;
}
inline void CameraSettings::clear_has_exposure() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void CameraSettings::clear_exposure() {
  exposure_ = 0;
  clear_has_exposure();
}
inline double CameraSettings::exposure() const {
  return exposure_;
}
inline void CameraSettings::set_exposure(double value) {
  set_has_exposure();
  exposure_ = value;
}

// optional double autogain = 15;
inline bool CameraSettings::has_autogain() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void CameraSettings::set_has_autogain() {
  _has_bits_[0] |= 0x00004000u;
}
inline void CameraSettings::clear_has_autogain() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void CameraSettings::clear_autogain() {
  autogain_ = 0;
  clear_has_autogain();
}
inline double CameraSettings::autogain() const {
  return autogain_;
}
inline void CameraSettings::set_autogain(double value) {
  set_has_autogain();
  autogain_ = value;
}

// optional double gain = 16;
inline bool CameraSettings::has_gain() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void CameraSettings::set_has_gain() {
  _has_bits_[0] |= 0x00008000u;
}
inline void CameraSettings::clear_has_gain() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void CameraSettings::clear_gain() {
  gain_ = 0;
  clear_has_gain();
}
inline double CameraSettings::gain() const {
  return gain_;
}
inline void CameraSettings::set_gain(double value) {
  set_has_gain();
  gain_ = value;
}

// optional double sharpness = 17;
inline bool CameraSettings::has_sharpness() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void CameraSettings::set_has_sharpness() {
  _has_bits_[0] |= 0x00010000u;
}
inline void CameraSettings::clear_has_sharpness() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void CameraSettings::clear_sharpness() {
  sharpness_ = 0;
  clear_has_sharpness();
}
inline double CameraSettings::sharpness() const {
  return sharpness_;
}
inline void CameraSettings::set_sharpness(double value) {
  set_has_sharpness();
  sharpness_ = value;
}

// optional double powerlinefreq = 18;
inline bool CameraSettings::has_powerlinefreq() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void CameraSettings::set_has_powerlinefreq() {
  _has_bits_[0] |= 0x00020000u;
}
inline void CameraSettings::clear_has_powerlinefreq() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void CameraSettings::clear_powerlinefreq() {
  powerlinefreq_ = 0;
  clear_has_powerlinefreq();
}
inline double CameraSettings::powerlinefreq() const {
  return powerlinefreq_;
}
inline void CameraSettings::set_powerlinefreq(double value) {
  set_has_powerlinefreq();
  powerlinefreq_ = value;
}

// optional double whitebalancetemp = 19;
inline bool CameraSettings::has_whitebalancetemp() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void CameraSettings::set_has_whitebalancetemp() {
  _has_bits_[0] |= 0x00040000u;
}
inline void CameraSettings::clear_has_whitebalancetemp() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void CameraSettings::clear_whitebalancetemp() {
  whitebalancetemp_ = 0;
  clear_has_whitebalancetemp();
}
inline double CameraSettings::whitebalancetemp() const {
  return whitebalancetemp_;
}
inline void CameraSettings::set_whitebalancetemp(double value) {
  set_has_whitebalancetemp();
  whitebalancetemp_ = value;
}

// optional double backlightcompensation = 20;
inline bool CameraSettings::has_backlightcompensation() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void CameraSettings::set_has_backlightcompensation() {
  _has_bits_[0] |= 0x00080000u;
}
inline void CameraSettings::clear_has_backlightcompensation() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void CameraSettings::clear_backlightcompensation() {
  backlightcompensation_ = 0;
  clear_has_backlightcompensation();
}
inline double CameraSettings::backlightcompensation() const {
  return backlightcompensation_;
}
inline void CameraSettings::set_backlightcompensation(double value) {
  set_has_backlightcompensation();
  backlightcompensation_ = value;
}

// optional double autoexposure = 21;
inline bool CameraSettings::has_autoexposure() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void CameraSettings::set_has_autoexposure() {
  _has_bits_[0] |= 0x00100000u;
}
inline void CameraSettings::clear_has_autoexposure() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void CameraSettings::clear_autoexposure() {
  autoexposure_ = 0;
  clear_has_autoexposure();
}
inline double CameraSettings::autoexposure() const {
  return autoexposure_;
}
inline void CameraSettings::set_autoexposure(double value) {
  set_has_autoexposure();
  autoexposure_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace protobuf

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_Representations_2eproto__INCLUDED
