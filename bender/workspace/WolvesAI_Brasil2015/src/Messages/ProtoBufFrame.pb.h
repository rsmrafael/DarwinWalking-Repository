// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ProtoBufFrame.proto

#ifndef PROTOBUF_ProtoBufFrame_2eproto__INCLUDED
#define PROTOBUF_ProtoBufFrame_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
// @@protoc_insertion_point(includes)

namespace protobuf {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_ProtoBufFrame_2eproto();
void protobuf_AssignDesc_ProtoBufFrame_2eproto();
void protobuf_ShutdownFile_ProtoBufFrame_2eproto();

class ImageData;
class Vector;
class BoundingBox;
class ProtoBufFrame;
class ProtoBufFrame_Object;
class ProtoBufFrame_DataBlob;
class ProtoBufFrame_RobotData;
class ProtoBufFrame_RobotData_PositionOrientation;
class ProtoBufFrame_Camera;
class ProtoBufFrame_Camera_CameraType;
class ProtoBufFrame_Camera_CameraSettings;

enum ImageFormat {
  YUV422_IMAGE = 1,
  BAYER_IMAGE = 2,
  RGB_IMAGE = 3
};
bool ImageFormat_IsValid(int value);
const ImageFormat ImageFormat_MIN = YUV422_IMAGE;
const ImageFormat ImageFormat_MAX = RGB_IMAGE;
const int ImageFormat_ARRAYSIZE = ImageFormat_MAX + 1;

enum ObjectType {
  UNKNOWN = 0,
  GOAL_POLE_YELLOW = 1,
  BALL = 2,
  GOAL_YELLOW_CROSSBAR = 3,
  ROBOT = 4,
  ROBOT_CYAN = 5,
  ROBOT_MAGENTA = 6,
  OBSTACLE = 7,
  FIELD_LINE = 8,
  LINE = 9,
  LINE_POINT = 10
};
bool ObjectType_IsValid(int value);
const ObjectType ObjectType_MIN = UNKNOWN;
const ObjectType ObjectType_MAX = LINE_POINT;
const int ObjectType_ARRAYSIZE = ObjectType_MAX + 1;

enum CameraLocation {
  HEAD_CENTER = 0,
  HEAD_LEFT = 1,
  HEAD_RIGHT = 2,
  HEAD_NOSE = 3,
  HEAD_CHIN = 4
};
bool CameraLocation_IsValid(int value);
const CameraLocation CameraLocation_MIN = HEAD_CENTER;
const CameraLocation CameraLocation_MAX = HEAD_CHIN;
const int CameraLocation_ARRAYSIZE = CameraLocation_MAX + 1;

// ===================================================================

class ImageData : public ::google::protobuf::MessageLite {
 public:
  ImageData();
  virtual ~ImageData();
  
  ImageData(const ImageData& from);
  
  inline ImageData& operator=(const ImageData& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const ImageData& default_instance();
  
  void Swap(ImageData* other);
  
  // implements Message ----------------------------------------------
  
  ImageData* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ImageData& from);
  void MergeFrom(const ImageData& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .protobuf.ImageFormat format = 1;
  inline bool has_format() const;
  inline void clear_format();
  static const int kFormatFieldNumber = 1;
  inline protobuf::ImageFormat format() const;
  inline void set_format(protobuf::ImageFormat value);
  
  // required bytes data = 2;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 2;
  inline const ::std::string& data() const;
  inline void set_data(const ::std::string& value);
  inline void set_data(const char* value);
  inline void set_data(const void* value, size_t size);
  inline ::std::string* mutable_data();
  inline ::std::string* release_data();
  
  // required bool compressed = 3 [default = false];
  inline bool has_compressed() const;
  inline void clear_compressed();
  static const int kCompressedFieldNumber = 3;
  inline bool compressed() const;
  inline void set_compressed(bool value);
  
  // required int32 width = 4;
  inline bool has_width() const;
  inline void clear_width();
  static const int kWidthFieldNumber = 4;
  inline ::google::protobuf::int32 width() const;
  inline void set_width(::google::protobuf::int32 value);
  
  // required int32 height = 5;
  inline bool has_height() const;
  inline void clear_height();
  static const int kHeightFieldNumber = 5;
  inline ::google::protobuf::int32 height() const;
  inline void set_height(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:protobuf.ImageData)
 private:
  inline void set_has_format();
  inline void clear_has_format();
  inline void set_has_data();
  inline void clear_has_data();
  inline void set_has_compressed();
  inline void clear_has_compressed();
  inline void set_has_width();
  inline void clear_has_width();
  inline void set_has_height();
  inline void clear_has_height();
  
  ::std::string* data_;
  int format_;
  bool compressed_;
  ::google::protobuf::int32 width_;
  ::google::protobuf::int32 height_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_ProtoBufFrame_2eproto();
  friend void protobuf_AssignDesc_ProtoBufFrame_2eproto();
  friend void protobuf_ShutdownFile_ProtoBufFrame_2eproto();
  
  void InitAsDefaultInstance();
  static ImageData* default_instance_;
};
// -------------------------------------------------------------------

class Vector : public ::google::protobuf::MessageLite {
 public:
  Vector();
  virtual ~Vector();
  
  Vector(const Vector& from);
  
  inline Vector& operator=(const Vector& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const Vector& default_instance();
  
  void Swap(Vector* other);
  
  // implements Message ----------------------------------------------
  
  Vector* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Vector& from);
  void MergeFrom(const Vector& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 x = 1;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 1;
  inline ::google::protobuf::int32 x() const;
  inline void set_x(::google::protobuf::int32 value);
  
  // required int32 y = 2;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 2;
  inline ::google::protobuf::int32 y() const;
  inline void set_y(::google::protobuf::int32 value);
  
  // required int32 z = 3;
  inline bool has_z() const;
  inline void clear_z();
  static const int kZFieldNumber = 3;
  inline ::google::protobuf::int32 z() const;
  inline void set_z(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:protobuf.Vector)
 private:
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();
  inline void set_has_z();
  inline void clear_has_z();
  
  ::google::protobuf::int32 x_;
  ::google::protobuf::int32 y_;
  ::google::protobuf::int32 z_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_ProtoBufFrame_2eproto();
  friend void protobuf_AssignDesc_ProtoBufFrame_2eproto();
  friend void protobuf_ShutdownFile_ProtoBufFrame_2eproto();
  
  void InitAsDefaultInstance();
  static Vector* default_instance_;
};
// -------------------------------------------------------------------

class BoundingBox : public ::google::protobuf::MessageLite {
 public:
  BoundingBox();
  virtual ~BoundingBox();
  
  BoundingBox(const BoundingBox& from);
  
  inline BoundingBox& operator=(const BoundingBox& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const BoundingBox& default_instance();
  
  void Swap(BoundingBox* other);
  
  // implements Message ----------------------------------------------
  
  BoundingBox* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const BoundingBox& from);
  void MergeFrom(const BoundingBox& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 x1 = 1;
  inline bool has_x1() const;
  inline void clear_x1();
  static const int kX1FieldNumber = 1;
  inline ::google::protobuf::int32 x1() const;
  inline void set_x1(::google::protobuf::int32 value);
  
  // required int32 y1 = 2;
  inline bool has_y1() const;
  inline void clear_y1();
  static const int kY1FieldNumber = 2;
  inline ::google::protobuf::int32 y1() const;
  inline void set_y1(::google::protobuf::int32 value);
  
  // required int32 x2 = 3;
  inline bool has_x2() const;
  inline void clear_x2();
  static const int kX2FieldNumber = 3;
  inline ::google::protobuf::int32 x2() const;
  inline void set_x2(::google::protobuf::int32 value);
  
  // required int32 y2 = 4;
  inline bool has_y2() const;
  inline void clear_y2();
  static const int kY2FieldNumber = 4;
  inline ::google::protobuf::int32 y2() const;
  inline void set_y2(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:protobuf.BoundingBox)
 private:
  inline void set_has_x1();
  inline void clear_has_x1();
  inline void set_has_y1();
  inline void clear_has_y1();
  inline void set_has_x2();
  inline void clear_has_x2();
  inline void set_has_y2();
  inline void clear_has_y2();
  
  ::google::protobuf::int32 x1_;
  ::google::protobuf::int32 y1_;
  ::google::protobuf::int32 x2_;
  ::google::protobuf::int32 y2_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_ProtoBufFrame_2eproto();
  friend void protobuf_AssignDesc_ProtoBufFrame_2eproto();
  friend void protobuf_ShutdownFile_ProtoBufFrame_2eproto();
  
  void InitAsDefaultInstance();
  static BoundingBox* default_instance_;
};
// -------------------------------------------------------------------

class ProtoBufFrame_Object : public ::google::protobuf::MessageLite {
 public:
  ProtoBufFrame_Object();
  virtual ~ProtoBufFrame_Object();
  
  ProtoBufFrame_Object(const ProtoBufFrame_Object& from);
  
  inline ProtoBufFrame_Object& operator=(const ProtoBufFrame_Object& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const ProtoBufFrame_Object& default_instance();
  
  void Swap(ProtoBufFrame_Object* other);
  
  // implements Message ----------------------------------------------
  
  ProtoBufFrame_Object* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ProtoBufFrame_Object& from);
  void MergeFrom(const ProtoBufFrame_Object& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .protobuf.ObjectType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline protobuf::ObjectType type() const;
  inline void set_type(protobuf::ObjectType value);
  
  // required .protobuf.BoundingBox box = 2;
  inline bool has_box() const;
  inline void clear_box();
  static const int kBoxFieldNumber = 2;
  inline const ::protobuf::BoundingBox& box() const;
  inline ::protobuf::BoundingBox* mutable_box();
  inline ::protobuf::BoundingBox* release_box();
  
  // @@protoc_insertion_point(class_scope:protobuf.ProtoBufFrame.Object)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_box();
  inline void clear_has_box();
  
  ::protobuf::BoundingBox* box_;
  int type_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_ProtoBufFrame_2eproto();
  friend void protobuf_AssignDesc_ProtoBufFrame_2eproto();
  friend void protobuf_ShutdownFile_ProtoBufFrame_2eproto();
  
  void InitAsDefaultInstance();
  static ProtoBufFrame_Object* default_instance_;
};
// -------------------------------------------------------------------

class ProtoBufFrame_DataBlob : public ::google::protobuf::MessageLite {
 public:
  ProtoBufFrame_DataBlob();
  virtual ~ProtoBufFrame_DataBlob();
  
  ProtoBufFrame_DataBlob(const ProtoBufFrame_DataBlob& from);
  
  inline ProtoBufFrame_DataBlob& operator=(const ProtoBufFrame_DataBlob& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const ProtoBufFrame_DataBlob& default_instance();
  
  void Swap(ProtoBufFrame_DataBlob* other);
  
  // implements Message ----------------------------------------------
  
  ProtoBufFrame_DataBlob* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ProtoBufFrame_DataBlob& from);
  void MergeFrom(const ProtoBufFrame_DataBlob& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 length = 1;
  inline bool has_length() const;
  inline void clear_length();
  static const int kLengthFieldNumber = 1;
  inline ::google::protobuf::int32 length() const;
  inline void set_length(::google::protobuf::int32 value);
  
  // required bytes data = 2;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 2;
  inline const ::std::string& data() const;
  inline void set_data(const ::std::string& value);
  inline void set_data(const char* value);
  inline void set_data(const void* value, size_t size);
  inline ::std::string* mutable_data();
  inline ::std::string* release_data();
  
  // @@protoc_insertion_point(class_scope:protobuf.ProtoBufFrame.DataBlob)
 private:
  inline void set_has_length();
  inline void clear_has_length();
  inline void set_has_data();
  inline void clear_has_data();
  
  ::std::string* data_;
  ::google::protobuf::int32 length_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_ProtoBufFrame_2eproto();
  friend void protobuf_AssignDesc_ProtoBufFrame_2eproto();
  friend void protobuf_ShutdownFile_ProtoBufFrame_2eproto();
  
  void InitAsDefaultInstance();
  static ProtoBufFrame_DataBlob* default_instance_;
};
// -------------------------------------------------------------------

class ProtoBufFrame_RobotData_PositionOrientation : public ::google::protobuf::MessageLite {
 public:
  ProtoBufFrame_RobotData_PositionOrientation();
  virtual ~ProtoBufFrame_RobotData_PositionOrientation();
  
  ProtoBufFrame_RobotData_PositionOrientation(const ProtoBufFrame_RobotData_PositionOrientation& from);
  
  inline ProtoBufFrame_RobotData_PositionOrientation& operator=(const ProtoBufFrame_RobotData_PositionOrientation& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const ProtoBufFrame_RobotData_PositionOrientation& default_instance();
  
  void Swap(ProtoBufFrame_RobotData_PositionOrientation* other);
  
  // implements Message ----------------------------------------------
  
  ProtoBufFrame_RobotData_PositionOrientation* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ProtoBufFrame_RobotData_PositionOrientation& from);
  void MergeFrom(const ProtoBufFrame_RobotData_PositionOrientation& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 x = 1;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 1;
  inline ::google::protobuf::int32 x() const;
  inline void set_x(::google::protobuf::int32 value);
  
  // required int32 y = 2;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 2;
  inline ::google::protobuf::int32 y() const;
  inline void set_y(::google::protobuf::int32 value);
  
  // required double r = 3;
  inline bool has_r() const;
  inline void clear_r();
  static const int kRFieldNumber = 3;
  inline double r() const;
  inline void set_r(double value);
  
  // @@protoc_insertion_point(class_scope:protobuf.ProtoBufFrame.RobotData.PositionOrientation)
 private:
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();
  inline void set_has_r();
  inline void clear_has_r();
  
  ::google::protobuf::int32 x_;
  ::google::protobuf::int32 y_;
  double r_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_ProtoBufFrame_2eproto();
  friend void protobuf_AssignDesc_ProtoBufFrame_2eproto();
  friend void protobuf_ShutdownFile_ProtoBufFrame_2eproto();
  
  void InitAsDefaultInstance();
  static ProtoBufFrame_RobotData_PositionOrientation* default_instance_;
};
// -------------------------------------------------------------------

class ProtoBufFrame_RobotData : public ::google::protobuf::MessageLite {
 public:
  ProtoBufFrame_RobotData();
  virtual ~ProtoBufFrame_RobotData();
  
  ProtoBufFrame_RobotData(const ProtoBufFrame_RobotData& from);
  
  inline ProtoBufFrame_RobotData& operator=(const ProtoBufFrame_RobotData& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const ProtoBufFrame_RobotData& default_instance();
  
  void Swap(ProtoBufFrame_RobotData* other);
  
  // implements Message ----------------------------------------------
  
  ProtoBufFrame_RobotData* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ProtoBufFrame_RobotData& from);
  void MergeFrom(const ProtoBufFrame_RobotData& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  typedef ProtoBufFrame_RobotData_PositionOrientation PositionOrientation;
  
  // accessors -------------------------------------------------------
  
  // optional int32 robotID = 1;
  inline bool has_robotid() const;
  inline void clear_robotid();
  static const int kRobotIDFieldNumber = 1;
  inline ::google::protobuf::int32 robotid() const;
  inline void set_robotid(::google::protobuf::int32 value);
  
  // optional string robotName = 2;
  inline bool has_robotname() const;
  inline void clear_robotname();
  static const int kRobotNameFieldNumber = 2;
  inline const ::std::string& robotname() const;
  inline void set_robotname(const ::std::string& value);
  inline void set_robotname(const char* value);
  inline void set_robotname(const char* value, size_t size);
  inline ::std::string* mutable_robotname();
  inline ::std::string* release_robotname();
  
  // optional .protobuf.ProtoBufFrame.RobotData.PositionOrientation ground_truth = 3;
  inline bool has_ground_truth() const;
  inline void clear_ground_truth();
  static const int kGroundTruthFieldNumber = 3;
  inline const ::protobuf::ProtoBufFrame_RobotData_PositionOrientation& ground_truth() const;
  inline ::protobuf::ProtoBufFrame_RobotData_PositionOrientation* mutable_ground_truth();
  inline ::protobuf::ProtoBufFrame_RobotData_PositionOrientation* release_ground_truth();
  
  // @@protoc_insertion_point(class_scope:protobuf.ProtoBufFrame.RobotData)
 private:
  inline void set_has_robotid();
  inline void clear_has_robotid();
  inline void set_has_robotname();
  inline void clear_has_robotname();
  inline void set_has_ground_truth();
  inline void clear_has_ground_truth();
  
  ::std::string* robotname_;
  ::protobuf::ProtoBufFrame_RobotData_PositionOrientation* ground_truth_;
  ::google::protobuf::int32 robotid_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_ProtoBufFrame_2eproto();
  friend void protobuf_AssignDesc_ProtoBufFrame_2eproto();
  friend void protobuf_ShutdownFile_ProtoBufFrame_2eproto();
  
  void InitAsDefaultInstance();
  static ProtoBufFrame_RobotData* default_instance_;
};
// -------------------------------------------------------------------

class ProtoBufFrame_Camera_CameraType : public ::google::protobuf::MessageLite {
 public:
  ProtoBufFrame_Camera_CameraType();
  virtual ~ProtoBufFrame_Camera_CameraType();
  
  ProtoBufFrame_Camera_CameraType(const ProtoBufFrame_Camera_CameraType& from);
  
  inline ProtoBufFrame_Camera_CameraType& operator=(const ProtoBufFrame_Camera_CameraType& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const ProtoBufFrame_Camera_CameraType& default_instance();
  
  void Swap(ProtoBufFrame_Camera_CameraType* other);
  
  // implements Message ----------------------------------------------
  
  ProtoBufFrame_Camera_CameraType* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ProtoBufFrame_Camera_CameraType& from);
  void MergeFrom(const ProtoBufFrame_Camera_CameraType& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .protobuf.CameraLocation location = 1;
  inline bool has_location() const;
  inline void clear_location();
  static const int kLocationFieldNumber = 1;
  inline protobuf::CameraLocation location() const;
  inline void set_location(protobuf::CameraLocation value);
  
  // optional string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  
  // optional double sensor_size_width = 3;
  inline bool has_sensor_size_width() const;
  inline void clear_sensor_size_width();
  static const int kSensorSizeWidthFieldNumber = 3;
  inline double sensor_size_width() const;
  inline void set_sensor_size_width(double value);
  
  // optional double sensor_size_height = 4;
  inline bool has_sensor_size_height() const;
  inline void clear_sensor_size_height();
  static const int kSensorSizeHeightFieldNumber = 4;
  inline double sensor_size_height() const;
  inline void set_sensor_size_height(double value);
  
  // optional string lens_name = 5;
  inline bool has_lens_name() const;
  inline void clear_lens_name();
  static const int kLensNameFieldNumber = 5;
  inline const ::std::string& lens_name() const;
  inline void set_lens_name(const ::std::string& value);
  inline void set_lens_name(const char* value);
  inline void set_lens_name(const char* value, size_t size);
  inline ::std::string* mutable_lens_name();
  inline ::std::string* release_lens_name();
  
  // optional double focal_length = 6;
  inline bool has_focal_length() const;
  inline void clear_focal_length();
  static const int kFocalLengthFieldNumber = 6;
  inline double focal_length() const;
  inline void set_focal_length(double value);
  
  // @@protoc_insertion_point(class_scope:protobuf.ProtoBufFrame.Camera.CameraType)
 private:
  inline void set_has_location();
  inline void clear_has_location();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_sensor_size_width();
  inline void clear_has_sensor_size_width();
  inline void set_has_sensor_size_height();
  inline void clear_has_sensor_size_height();
  inline void set_has_lens_name();
  inline void clear_has_lens_name();
  inline void set_has_focal_length();
  inline void clear_has_focal_length();
  
  ::std::string* name_;
  double sensor_size_width_;
  double sensor_size_height_;
  ::std::string* lens_name_;
  double focal_length_;
  int location_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  friend void  protobuf_AddDesc_ProtoBufFrame_2eproto();
  friend void protobuf_AssignDesc_ProtoBufFrame_2eproto();
  friend void protobuf_ShutdownFile_ProtoBufFrame_2eproto();
  
  void InitAsDefaultInstance();
  static ProtoBufFrame_Camera_CameraType* default_instance_;
};
// -------------------------------------------------------------------

class ProtoBufFrame_Camera_CameraSettings : public ::google::protobuf::MessageLite {
 public:
  ProtoBufFrame_Camera_CameraSettings();
  virtual ~ProtoBufFrame_Camera_CameraSettings();
  
  ProtoBufFrame_Camera_CameraSettings(const ProtoBufFrame_Camera_CameraSettings& from);
  
  inline ProtoBufFrame_Camera_CameraSettings& operator=(const ProtoBufFrame_Camera_CameraSettings& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const ProtoBufFrame_Camera_CameraSettings& default_instance();
  
  void Swap(ProtoBufFrame_Camera_CameraSettings* other);
  
  // implements Message ----------------------------------------------
  
  ProtoBufFrame_Camera_CameraSettings* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ProtoBufFrame_Camera_CameraSettings& from);
  void MergeFrom(const ProtoBufFrame_Camera_CameraSettings& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional double gain = 1;
  inline bool has_gain() const;
  inline void clear_gain();
  static const int kGainFieldNumber = 1;
  inline double gain() const;
  inline void set_gain(double value);
  
  // optional double brightness = 2;
  inline bool has_brightness() const;
  inline void clear_brightness();
  static const int kBrightnessFieldNumber = 2;
  inline double brightness() const;
  inline void set_brightness(double value);
  
  // optional double shutter = 3;
  inline bool has_shutter() const;
  inline void clear_shutter();
  static const int kShutterFieldNumber = 3;
  inline double shutter() const;
  inline void set_shutter(double value);
  
  // optional double white_balance = 4;
  inline bool has_white_balance() const;
  inline void clear_white_balance();
  static const int kWhiteBalanceFieldNumber = 4;
  inline double white_balance() const;
  inline void set_white_balance(double value);
  
  // optional double saturation = 5;
  inline bool has_saturation() const;
  inline void clear_saturation();
  static const int kSaturationFieldNumber = 5;
  inline double saturation() const;
  inline void set_saturation(double value);
  
  // optional double contrast = 6;
  inline bool has_contrast() const;
  inline void clear_contrast();
  static const int kContrastFieldNumber = 6;
  inline double contrast() const;
  inline void set_contrast(double value);
  
  // optional double sharpness = 7;
  inline bool has_sharpness() const;
  inline void clear_sharpness();
  static const int kSharpnessFieldNumber = 7;
  inline double sharpness() const;
  inline void set_sharpness(double value);
  
  // optional double hue = 8;
  inline bool has_hue() const;
  inline void clear_hue();
  static const int kHueFieldNumber = 8;
  inline double hue() const;
  inline void set_hue(double value);
  
  // optional double gamma = 9;
  inline bool has_gamma() const;
  inline void clear_gamma();
  static const int kGammaFieldNumber = 9;
  inline double gamma() const;
  inline void set_gamma(double value);
  
  // @@protoc_insertion_point(class_scope:protobuf.ProtoBufFrame.Camera.CameraSettings)
 private:
  inline void set_has_gain();
  inline void clear_has_gain();
  inline void set_has_brightness();
  inline void clear_has_brightness();
  inline void set_has_shutter();
  inline void clear_has_shutter();
  inline void set_has_white_balance();
  inline void clear_has_white_balance();
  inline void set_has_saturation();
  inline void clear_has_saturation();
  inline void set_has_contrast();
  inline void clear_has_contrast();
  inline void set_has_sharpness();
  inline void clear_has_sharpness();
  inline void set_has_hue();
  inline void clear_has_hue();
  inline void set_has_gamma();
  inline void clear_has_gamma();
  
  double gain_;
  double brightness_;
  double shutter_;
  double white_balance_;
  double saturation_;
  double contrast_;
  double sharpness_;
  double hue_;
  double gamma_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];
  
  friend void  protobuf_AddDesc_ProtoBufFrame_2eproto();
  friend void protobuf_AssignDesc_ProtoBufFrame_2eproto();
  friend void protobuf_ShutdownFile_ProtoBufFrame_2eproto();
  
  void InitAsDefaultInstance();
  static ProtoBufFrame_Camera_CameraSettings* default_instance_;
};
// -------------------------------------------------------------------

class ProtoBufFrame_Camera : public ::google::protobuf::MessageLite {
 public:
  ProtoBufFrame_Camera();
  virtual ~ProtoBufFrame_Camera();
  
  ProtoBufFrame_Camera(const ProtoBufFrame_Camera& from);
  
  inline ProtoBufFrame_Camera& operator=(const ProtoBufFrame_Camera& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const ProtoBufFrame_Camera& default_instance();
  
  void Swap(ProtoBufFrame_Camera* other);
  
  // implements Message ----------------------------------------------
  
  ProtoBufFrame_Camera* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ProtoBufFrame_Camera& from);
  void MergeFrom(const ProtoBufFrame_Camera& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  typedef ProtoBufFrame_Camera_CameraType CameraType;
  typedef ProtoBufFrame_Camera_CameraSettings CameraSettings;
  
  // accessors -------------------------------------------------------
  
  // required .protobuf.ProtoBufFrame.Camera.CameraType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline const ::protobuf::ProtoBufFrame_Camera_CameraType& type() const;
  inline ::protobuf::ProtoBufFrame_Camera_CameraType* mutable_type();
  inline ::protobuf::ProtoBufFrame_Camera_CameraType* release_type();
  
  // required .protobuf.ImageData image_data = 2;
  inline bool has_image_data() const;
  inline void clear_image_data();
  static const int kImageDataFieldNumber = 2;
  inline const ::protobuf::ImageData& image_data() const;
  inline ::protobuf::ImageData* mutable_image_data();
  inline ::protobuf::ImageData* release_image_data();
  
  // repeated .protobuf.ProtoBufFrame.Object objects = 3;
  inline int objects_size() const;
  inline void clear_objects();
  static const int kObjectsFieldNumber = 3;
  inline const ::protobuf::ProtoBufFrame_Object& objects(int index) const;
  inline ::protobuf::ProtoBufFrame_Object* mutable_objects(int index);
  inline ::protobuf::ProtoBufFrame_Object* add_objects();
  inline const ::google::protobuf::RepeatedPtrField< ::protobuf::ProtoBufFrame_Object >&
      objects() const;
  inline ::google::protobuf::RepeatedPtrField< ::protobuf::ProtoBufFrame_Object >*
      mutable_objects();
  
  // optional .protobuf.ProtoBufFrame.Camera.CameraSettings settings = 4;
  inline bool has_settings() const;
  inline void clear_settings();
  static const int kSettingsFieldNumber = 4;
  inline const ::protobuf::ProtoBufFrame_Camera_CameraSettings& settings() const;
  inline ::protobuf::ProtoBufFrame_Camera_CameraSettings* mutable_settings();
  inline ::protobuf::ProtoBufFrame_Camera_CameraSettings* release_settings();
  
  // optional .protobuf.ProtoBufFrame.DataBlob team_data = 5;
  inline bool has_team_data() const;
  inline void clear_team_data();
  static const int kTeamDataFieldNumber = 5;
  inline const ::protobuf::ProtoBufFrame_DataBlob& team_data() const;
  inline ::protobuf::ProtoBufFrame_DataBlob* mutable_team_data();
  inline ::protobuf::ProtoBufFrame_DataBlob* release_team_data();
  
  // optional .protobuf.Vector camera_position = 6;
  inline bool has_camera_position() const;
  inline void clear_camera_position();
  static const int kCameraPositionFieldNumber = 6;
  inline const ::protobuf::Vector& camera_position() const;
  inline ::protobuf::Vector* mutable_camera_position();
  inline ::protobuf::Vector* release_camera_position();
  
  // optional .protobuf.Vector optical_axis = 7;
  inline bool has_optical_axis() const;
  inline void clear_optical_axis();
  static const int kOpticalAxisFieldNumber = 7;
  inline const ::protobuf::Vector& optical_axis() const;
  inline ::protobuf::Vector* mutable_optical_axis();
  inline ::protobuf::Vector* release_optical_axis();
  
  // @@protoc_insertion_point(class_scope:protobuf.ProtoBufFrame.Camera)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_image_data();
  inline void clear_has_image_data();
  inline void set_has_settings();
  inline void clear_has_settings();
  inline void set_has_team_data();
  inline void clear_has_team_data();
  inline void set_has_camera_position();
  inline void clear_has_camera_position();
  inline void set_has_optical_axis();
  inline void clear_has_optical_axis();
  
  ::protobuf::ProtoBufFrame_Camera_CameraType* type_;
  ::protobuf::ImageData* image_data_;
  ::google::protobuf::RepeatedPtrField< ::protobuf::ProtoBufFrame_Object > objects_;
  ::protobuf::ProtoBufFrame_Camera_CameraSettings* settings_;
  ::protobuf::ProtoBufFrame_DataBlob* team_data_;
  ::protobuf::Vector* camera_position_;
  ::protobuf::Vector* optical_axis_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];
  
  friend void  protobuf_AddDesc_ProtoBufFrame_2eproto();
  friend void protobuf_AssignDesc_ProtoBufFrame_2eproto();
  friend void protobuf_ShutdownFile_ProtoBufFrame_2eproto();
  
  void InitAsDefaultInstance();
  static ProtoBufFrame_Camera* default_instance_;
};
// -------------------------------------------------------------------

class ProtoBufFrame : public ::google::protobuf::MessageLite {
 public:
  ProtoBufFrame();
  virtual ~ProtoBufFrame();
  
  ProtoBufFrame(const ProtoBufFrame& from);
  
  inline ProtoBufFrame& operator=(const ProtoBufFrame& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const ProtoBufFrame& default_instance();
  
  void Swap(ProtoBufFrame* other);
  
  // implements Message ----------------------------------------------
  
  ProtoBufFrame* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ProtoBufFrame& from);
  void MergeFrom(const ProtoBufFrame& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  typedef ProtoBufFrame_Object Object;
  typedef ProtoBufFrame_DataBlob DataBlob;
  typedef ProtoBufFrame_RobotData RobotData;
  typedef ProtoBufFrame_Camera Camera;
  
  // accessors -------------------------------------------------------
  
  // optional int32 time = 1;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 1;
  inline ::google::protobuf::int32 time() const;
  inline void set_time(::google::protobuf::int32 value);
  
  // optional int32 sequence_id = 2;
  inline bool has_sequence_id() const;
  inline void clear_sequence_id();
  static const int kSequenceIdFieldNumber = 2;
  inline ::google::protobuf::int32 sequence_id() const;
  inline void set_sequence_id(::google::protobuf::int32 value);
  
  // optional string comment = 3;
  inline bool has_comment() const;
  inline void clear_comment();
  static const int kCommentFieldNumber = 3;
  inline const ::std::string& comment() const;
  inline void set_comment(const ::std::string& value);
  inline void set_comment(const char* value);
  inline void set_comment(const char* value, size_t size);
  inline ::std::string* mutable_comment();
  inline ::std::string* release_comment();
  
  // optional string capture_location = 4;
  inline bool has_capture_location() const;
  inline void clear_capture_location();
  static const int kCaptureLocationFieldNumber = 4;
  inline const ::std::string& capture_location() const;
  inline void set_capture_location(const ::std::string& value);
  inline void set_capture_location(const char* value);
  inline void set_capture_location(const char* value, size_t size);
  inline ::std::string* mutable_capture_location();
  inline ::std::string* release_capture_location();
  
  // optional .protobuf.ProtoBufFrame.RobotData robot_data = 5;
  inline bool has_robot_data() const;
  inline void clear_robot_data();
  static const int kRobotDataFieldNumber = 5;
  inline const ::protobuf::ProtoBufFrame_RobotData& robot_data() const;
  inline ::protobuf::ProtoBufFrame_RobotData* mutable_robot_data();
  inline ::protobuf::ProtoBufFrame_RobotData* release_robot_data();
  
  // repeated .protobuf.ProtoBufFrame.Camera camera = 6;
  inline int camera_size() const;
  inline void clear_camera();
  static const int kCameraFieldNumber = 6;
  inline const ::protobuf::ProtoBufFrame_Camera& camera(int index) const;
  inline ::protobuf::ProtoBufFrame_Camera* mutable_camera(int index);
  inline ::protobuf::ProtoBufFrame_Camera* add_camera();
  inline const ::google::protobuf::RepeatedPtrField< ::protobuf::ProtoBufFrame_Camera >&
      camera() const;
  inline ::google::protobuf::RepeatedPtrField< ::protobuf::ProtoBufFrame_Camera >*
      mutable_camera();
  
  // repeated .protobuf.ProtoBufFrame.Object merged_objects = 7;
  inline int merged_objects_size() const;
  inline void clear_merged_objects();
  static const int kMergedObjectsFieldNumber = 7;
  inline const ::protobuf::ProtoBufFrame_Object& merged_objects(int index) const;
  inline ::protobuf::ProtoBufFrame_Object* mutable_merged_objects(int index);
  inline ::protobuf::ProtoBufFrame_Object* add_merged_objects();
  inline const ::google::protobuf::RepeatedPtrField< ::protobuf::ProtoBufFrame_Object >&
      merged_objects() const;
  inline ::google::protobuf::RepeatedPtrField< ::protobuf::ProtoBufFrame_Object >*
      mutable_merged_objects();
  
  // optional .protobuf.ProtoBufFrame.DataBlob team_data = 8;
  inline bool has_team_data() const;
  inline void clear_team_data();
  static const int kTeamDataFieldNumber = 8;
  inline const ::protobuf::ProtoBufFrame_DataBlob& team_data() const;
  inline ::protobuf::ProtoBufFrame_DataBlob* mutable_team_data();
  inline ::protobuf::ProtoBufFrame_DataBlob* release_team_data();
  
  // @@protoc_insertion_point(class_scope:protobuf.ProtoBufFrame)
 private:
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_sequence_id();
  inline void clear_has_sequence_id();
  inline void set_has_comment();
  inline void clear_has_comment();
  inline void set_has_capture_location();
  inline void clear_has_capture_location();
  inline void set_has_robot_data();
  inline void clear_has_robot_data();
  inline void set_has_team_data();
  inline void clear_has_team_data();
  
  ::google::protobuf::int32 time_;
  ::google::protobuf::int32 sequence_id_;
  ::std::string* comment_;
  ::std::string* capture_location_;
  ::protobuf::ProtoBufFrame_RobotData* robot_data_;
  ::google::protobuf::RepeatedPtrField< ::protobuf::ProtoBufFrame_Camera > camera_;
  ::google::protobuf::RepeatedPtrField< ::protobuf::ProtoBufFrame_Object > merged_objects_;
  ::protobuf::ProtoBufFrame_DataBlob* team_data_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];
  
  friend void  protobuf_AddDesc_ProtoBufFrame_2eproto();
  friend void protobuf_AssignDesc_ProtoBufFrame_2eproto();
  friend void protobuf_ShutdownFile_ProtoBufFrame_2eproto();
  
  void InitAsDefaultInstance();
  static ProtoBufFrame* default_instance_;
};
// ===================================================================


// ===================================================================

// ImageData

// required .protobuf.ImageFormat format = 1;
inline bool ImageData::has_format() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ImageData::set_has_format() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ImageData::clear_has_format() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ImageData::clear_format() {
  format_ = 1;
  clear_has_format();
}
inline protobuf::ImageFormat ImageData::format() const {
  return static_cast< protobuf::ImageFormat >(format_);
}
inline void ImageData::set_format(protobuf::ImageFormat value) {
  GOOGLE_DCHECK(protobuf::ImageFormat_IsValid(value));
  set_has_format();
  format_ = value;
}

// required bytes data = 2;
inline bool ImageData::has_data() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ImageData::set_has_data() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ImageData::clear_has_data() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ImageData::clear_data() {
  if (data_ != &::google::protobuf::internal::kEmptyString) {
    data_->clear();
  }
  clear_has_data();
}
inline const ::std::string& ImageData::data() const {
  return *data_;
}
inline void ImageData::set_data(const ::std::string& value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void ImageData::set_data(const char* value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void ImageData::set_data(const void* value, size_t size) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ImageData::mutable_data() {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  return data_;
}
inline ::std::string* ImageData::release_data() {
  clear_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = data_;
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required bool compressed = 3 [default = false];
inline bool ImageData::has_compressed() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ImageData::set_has_compressed() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ImageData::clear_has_compressed() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ImageData::clear_compressed() {
  compressed_ = false;
  clear_has_compressed();
}
inline bool ImageData::compressed() const {
  return compressed_;
}
inline void ImageData::set_compressed(bool value) {
  set_has_compressed();
  compressed_ = value;
}

// required int32 width = 4;
inline bool ImageData::has_width() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ImageData::set_has_width() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ImageData::clear_has_width() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ImageData::clear_width() {
  width_ = 0;
  clear_has_width();
}
inline ::google::protobuf::int32 ImageData::width() const {
  return width_;
}
inline void ImageData::set_width(::google::protobuf::int32 value) {
  set_has_width();
  width_ = value;
}

// required int32 height = 5;
inline bool ImageData::has_height() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ImageData::set_has_height() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ImageData::clear_has_height() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ImageData::clear_height() {
  height_ = 0;
  clear_has_height();
}
inline ::google::protobuf::int32 ImageData::height() const {
  return height_;
}
inline void ImageData::set_height(::google::protobuf::int32 value) {
  set_has_height();
  height_ = value;
}

// -------------------------------------------------------------------

// Vector

// required int32 x = 1;
inline bool Vector::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Vector::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Vector::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Vector::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline ::google::protobuf::int32 Vector::x() const {
  return x_;
}
inline void Vector::set_x(::google::protobuf::int32 value) {
  set_has_x();
  x_ = value;
}

// required int32 y = 2;
inline bool Vector::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Vector::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Vector::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Vector::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline ::google::protobuf::int32 Vector::y() const {
  return y_;
}
inline void Vector::set_y(::google::protobuf::int32 value) {
  set_has_y();
  y_ = value;
}

// required int32 z = 3;
inline bool Vector::has_z() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Vector::set_has_z() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Vector::clear_has_z() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Vector::clear_z() {
  z_ = 0;
  clear_has_z();
}
inline ::google::protobuf::int32 Vector::z() const {
  return z_;
}
inline void Vector::set_z(::google::protobuf::int32 value) {
  set_has_z();
  z_ = value;
}

// -------------------------------------------------------------------

// BoundingBox

// required int32 x1 = 1;
inline bool BoundingBox::has_x1() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BoundingBox::set_has_x1() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BoundingBox::clear_has_x1() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BoundingBox::clear_x1() {
  x1_ = 0;
  clear_has_x1();
}
inline ::google::protobuf::int32 BoundingBox::x1() const {
  return x1_;
}
inline void BoundingBox::set_x1(::google::protobuf::int32 value) {
  set_has_x1();
  x1_ = value;
}

// required int32 y1 = 2;
inline bool BoundingBox::has_y1() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BoundingBox::set_has_y1() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BoundingBox::clear_has_y1() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BoundingBox::clear_y1() {
  y1_ = 0;
  clear_has_y1();
}
inline ::google::protobuf::int32 BoundingBox::y1() const {
  return y1_;
}
inline void BoundingBox::set_y1(::google::protobuf::int32 value) {
  set_has_y1();
  y1_ = value;
}

// required int32 x2 = 3;
inline bool BoundingBox::has_x2() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BoundingBox::set_has_x2() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BoundingBox::clear_has_x2() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BoundingBox::clear_x2() {
  x2_ = 0;
  clear_has_x2();
}
inline ::google::protobuf::int32 BoundingBox::x2() const {
  return x2_;
}
inline void BoundingBox::set_x2(::google::protobuf::int32 value) {
  set_has_x2();
  x2_ = value;
}

// required int32 y2 = 4;
inline bool BoundingBox::has_y2() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BoundingBox::set_has_y2() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BoundingBox::clear_has_y2() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BoundingBox::clear_y2() {
  y2_ = 0;
  clear_has_y2();
}
inline ::google::protobuf::int32 BoundingBox::y2() const {
  return y2_;
}
inline void BoundingBox::set_y2(::google::protobuf::int32 value) {
  set_has_y2();
  y2_ = value;
}

// -------------------------------------------------------------------

// ProtoBufFrame_Object

// required .protobuf.ObjectType type = 1;
inline bool ProtoBufFrame_Object::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ProtoBufFrame_Object::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ProtoBufFrame_Object::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ProtoBufFrame_Object::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline protobuf::ObjectType ProtoBufFrame_Object::type() const {
  return static_cast< protobuf::ObjectType >(type_);
}
inline void ProtoBufFrame_Object::set_type(protobuf::ObjectType value) {
  GOOGLE_DCHECK(protobuf::ObjectType_IsValid(value));
  set_has_type();
  type_ = value;
}

// required .protobuf.BoundingBox box = 2;
inline bool ProtoBufFrame_Object::has_box() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ProtoBufFrame_Object::set_has_box() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ProtoBufFrame_Object::clear_has_box() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ProtoBufFrame_Object::clear_box() {
  if (box_ != NULL) box_->::protobuf::BoundingBox::Clear();
  clear_has_box();
}
inline const ::protobuf::BoundingBox& ProtoBufFrame_Object::box() const {
  return box_ != NULL ? *box_ : *default_instance_->box_;
}
inline ::protobuf::BoundingBox* ProtoBufFrame_Object::mutable_box() {
  set_has_box();
  if (box_ == NULL) box_ = new ::protobuf::BoundingBox;
  return box_;
}
inline ::protobuf::BoundingBox* ProtoBufFrame_Object::release_box() {
  clear_has_box();
  ::protobuf::BoundingBox* temp = box_;
  box_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// ProtoBufFrame_DataBlob

// required int32 length = 1;
inline bool ProtoBufFrame_DataBlob::has_length() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ProtoBufFrame_DataBlob::set_has_length() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ProtoBufFrame_DataBlob::clear_has_length() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ProtoBufFrame_DataBlob::clear_length() {
  length_ = 0;
  clear_has_length();
}
inline ::google::protobuf::int32 ProtoBufFrame_DataBlob::length() const {
  return length_;
}
inline void ProtoBufFrame_DataBlob::set_length(::google::protobuf::int32 value) {
  set_has_length();
  length_ = value;
}

// required bytes data = 2;
inline bool ProtoBufFrame_DataBlob::has_data() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ProtoBufFrame_DataBlob::set_has_data() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ProtoBufFrame_DataBlob::clear_has_data() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ProtoBufFrame_DataBlob::clear_data() {
  if (data_ != &::google::protobuf::internal::kEmptyString) {
    data_->clear();
  }
  clear_has_data();
}
inline const ::std::string& ProtoBufFrame_DataBlob::data() const {
  return *data_;
}
inline void ProtoBufFrame_DataBlob::set_data(const ::std::string& value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void ProtoBufFrame_DataBlob::set_data(const char* value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void ProtoBufFrame_DataBlob::set_data(const void* value, size_t size) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ProtoBufFrame_DataBlob::mutable_data() {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  return data_;
}
inline ::std::string* ProtoBufFrame_DataBlob::release_data() {
  clear_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = data_;
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// ProtoBufFrame_RobotData_PositionOrientation

// required int32 x = 1;
inline bool ProtoBufFrame_RobotData_PositionOrientation::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ProtoBufFrame_RobotData_PositionOrientation::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ProtoBufFrame_RobotData_PositionOrientation::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ProtoBufFrame_RobotData_PositionOrientation::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline ::google::protobuf::int32 ProtoBufFrame_RobotData_PositionOrientation::x() const {
  return x_;
}
inline void ProtoBufFrame_RobotData_PositionOrientation::set_x(::google::protobuf::int32 value) {
  set_has_x();
  x_ = value;
}

// required int32 y = 2;
inline bool ProtoBufFrame_RobotData_PositionOrientation::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ProtoBufFrame_RobotData_PositionOrientation::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ProtoBufFrame_RobotData_PositionOrientation::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ProtoBufFrame_RobotData_PositionOrientation::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline ::google::protobuf::int32 ProtoBufFrame_RobotData_PositionOrientation::y() const {
  return y_;
}
inline void ProtoBufFrame_RobotData_PositionOrientation::set_y(::google::protobuf::int32 value) {
  set_has_y();
  y_ = value;
}

// required double r = 3;
inline bool ProtoBufFrame_RobotData_PositionOrientation::has_r() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ProtoBufFrame_RobotData_PositionOrientation::set_has_r() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ProtoBufFrame_RobotData_PositionOrientation::clear_has_r() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ProtoBufFrame_RobotData_PositionOrientation::clear_r() {
  r_ = 0;
  clear_has_r();
}
inline double ProtoBufFrame_RobotData_PositionOrientation::r() const {
  return r_;
}
inline void ProtoBufFrame_RobotData_PositionOrientation::set_r(double value) {
  set_has_r();
  r_ = value;
}

// -------------------------------------------------------------------

// ProtoBufFrame_RobotData

// optional int32 robotID = 1;
inline bool ProtoBufFrame_RobotData::has_robotid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ProtoBufFrame_RobotData::set_has_robotid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ProtoBufFrame_RobotData::clear_has_robotid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ProtoBufFrame_RobotData::clear_robotid() {
  robotid_ = 0;
  clear_has_robotid();
}
inline ::google::protobuf::int32 ProtoBufFrame_RobotData::robotid() const {
  return robotid_;
}
inline void ProtoBufFrame_RobotData::set_robotid(::google::protobuf::int32 value) {
  set_has_robotid();
  robotid_ = value;
}

// optional string robotName = 2;
inline bool ProtoBufFrame_RobotData::has_robotname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ProtoBufFrame_RobotData::set_has_robotname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ProtoBufFrame_RobotData::clear_has_robotname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ProtoBufFrame_RobotData::clear_robotname() {
  if (robotname_ != &::google::protobuf::internal::kEmptyString) {
    robotname_->clear();
  }
  clear_has_robotname();
}
inline const ::std::string& ProtoBufFrame_RobotData::robotname() const {
  return *robotname_;
}
inline void ProtoBufFrame_RobotData::set_robotname(const ::std::string& value) {
  set_has_robotname();
  if (robotname_ == &::google::protobuf::internal::kEmptyString) {
    robotname_ = new ::std::string;
  }
  robotname_->assign(value);
}
inline void ProtoBufFrame_RobotData::set_robotname(const char* value) {
  set_has_robotname();
  if (robotname_ == &::google::protobuf::internal::kEmptyString) {
    robotname_ = new ::std::string;
  }
  robotname_->assign(value);
}
inline void ProtoBufFrame_RobotData::set_robotname(const char* value, size_t size) {
  set_has_robotname();
  if (robotname_ == &::google::protobuf::internal::kEmptyString) {
    robotname_ = new ::std::string;
  }
  robotname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ProtoBufFrame_RobotData::mutable_robotname() {
  set_has_robotname();
  if (robotname_ == &::google::protobuf::internal::kEmptyString) {
    robotname_ = new ::std::string;
  }
  return robotname_;
}
inline ::std::string* ProtoBufFrame_RobotData::release_robotname() {
  clear_has_robotname();
  if (robotname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = robotname_;
    robotname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional .protobuf.ProtoBufFrame.RobotData.PositionOrientation ground_truth = 3;
inline bool ProtoBufFrame_RobotData::has_ground_truth() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ProtoBufFrame_RobotData::set_has_ground_truth() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ProtoBufFrame_RobotData::clear_has_ground_truth() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ProtoBufFrame_RobotData::clear_ground_truth() {
  if (ground_truth_ != NULL) ground_truth_->::protobuf::ProtoBufFrame_RobotData_PositionOrientation::Clear();
  clear_has_ground_truth();
}
inline const ::protobuf::ProtoBufFrame_RobotData_PositionOrientation& ProtoBufFrame_RobotData::ground_truth() const {
  return ground_truth_ != NULL ? *ground_truth_ : *default_instance_->ground_truth_;
}
inline ::protobuf::ProtoBufFrame_RobotData_PositionOrientation* ProtoBufFrame_RobotData::mutable_ground_truth() {
  set_has_ground_truth();
  if (ground_truth_ == NULL) ground_truth_ = new ::protobuf::ProtoBufFrame_RobotData_PositionOrientation;
  return ground_truth_;
}
inline ::protobuf::ProtoBufFrame_RobotData_PositionOrientation* ProtoBufFrame_RobotData::release_ground_truth() {
  clear_has_ground_truth();
  ::protobuf::ProtoBufFrame_RobotData_PositionOrientation* temp = ground_truth_;
  ground_truth_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// ProtoBufFrame_Camera_CameraType

// required .protobuf.CameraLocation location = 1;
inline bool ProtoBufFrame_Camera_CameraType::has_location() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ProtoBufFrame_Camera_CameraType::set_has_location() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ProtoBufFrame_Camera_CameraType::clear_has_location() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ProtoBufFrame_Camera_CameraType::clear_location() {
  location_ = 0;
  clear_has_location();
}
inline protobuf::CameraLocation ProtoBufFrame_Camera_CameraType::location() const {
  return static_cast< protobuf::CameraLocation >(location_);
}
inline void ProtoBufFrame_Camera_CameraType::set_location(protobuf::CameraLocation value) {
  GOOGLE_DCHECK(protobuf::CameraLocation_IsValid(value));
  set_has_location();
  location_ = value;
}

// optional string name = 2;
inline bool ProtoBufFrame_Camera_CameraType::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ProtoBufFrame_Camera_CameraType::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ProtoBufFrame_Camera_CameraType::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ProtoBufFrame_Camera_CameraType::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& ProtoBufFrame_Camera_CameraType::name() const {
  return *name_;
}
inline void ProtoBufFrame_Camera_CameraType::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ProtoBufFrame_Camera_CameraType::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ProtoBufFrame_Camera_CameraType::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ProtoBufFrame_Camera_CameraType::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* ProtoBufFrame_Camera_CameraType::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional double sensor_size_width = 3;
inline bool ProtoBufFrame_Camera_CameraType::has_sensor_size_width() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ProtoBufFrame_Camera_CameraType::set_has_sensor_size_width() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ProtoBufFrame_Camera_CameraType::clear_has_sensor_size_width() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ProtoBufFrame_Camera_CameraType::clear_sensor_size_width() {
  sensor_size_width_ = 0;
  clear_has_sensor_size_width();
}
inline double ProtoBufFrame_Camera_CameraType::sensor_size_width() const {
  return sensor_size_width_;
}
inline void ProtoBufFrame_Camera_CameraType::set_sensor_size_width(double value) {
  set_has_sensor_size_width();
  sensor_size_width_ = value;
}

// optional double sensor_size_height = 4;
inline bool ProtoBufFrame_Camera_CameraType::has_sensor_size_height() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ProtoBufFrame_Camera_CameraType::set_has_sensor_size_height() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ProtoBufFrame_Camera_CameraType::clear_has_sensor_size_height() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ProtoBufFrame_Camera_CameraType::clear_sensor_size_height() {
  sensor_size_height_ = 0;
  clear_has_sensor_size_height();
}
inline double ProtoBufFrame_Camera_CameraType::sensor_size_height() const {
  return sensor_size_height_;
}
inline void ProtoBufFrame_Camera_CameraType::set_sensor_size_height(double value) {
  set_has_sensor_size_height();
  sensor_size_height_ = value;
}

// optional string lens_name = 5;
inline bool ProtoBufFrame_Camera_CameraType::has_lens_name() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ProtoBufFrame_Camera_CameraType::set_has_lens_name() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ProtoBufFrame_Camera_CameraType::clear_has_lens_name() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ProtoBufFrame_Camera_CameraType::clear_lens_name() {
  if (lens_name_ != &::google::protobuf::internal::kEmptyString) {
    lens_name_->clear();
  }
  clear_has_lens_name();
}
inline const ::std::string& ProtoBufFrame_Camera_CameraType::lens_name() const {
  return *lens_name_;
}
inline void ProtoBufFrame_Camera_CameraType::set_lens_name(const ::std::string& value) {
  set_has_lens_name();
  if (lens_name_ == &::google::protobuf::internal::kEmptyString) {
    lens_name_ = new ::std::string;
  }
  lens_name_->assign(value);
}
inline void ProtoBufFrame_Camera_CameraType::set_lens_name(const char* value) {
  set_has_lens_name();
  if (lens_name_ == &::google::protobuf::internal::kEmptyString) {
    lens_name_ = new ::std::string;
  }
  lens_name_->assign(value);
}
inline void ProtoBufFrame_Camera_CameraType::set_lens_name(const char* value, size_t size) {
  set_has_lens_name();
  if (lens_name_ == &::google::protobuf::internal::kEmptyString) {
    lens_name_ = new ::std::string;
  }
  lens_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ProtoBufFrame_Camera_CameraType::mutable_lens_name() {
  set_has_lens_name();
  if (lens_name_ == &::google::protobuf::internal::kEmptyString) {
    lens_name_ = new ::std::string;
  }
  return lens_name_;
}
inline ::std::string* ProtoBufFrame_Camera_CameraType::release_lens_name() {
  clear_has_lens_name();
  if (lens_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = lens_name_;
    lens_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional double focal_length = 6;
inline bool ProtoBufFrame_Camera_CameraType::has_focal_length() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ProtoBufFrame_Camera_CameraType::set_has_focal_length() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ProtoBufFrame_Camera_CameraType::clear_has_focal_length() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ProtoBufFrame_Camera_CameraType::clear_focal_length() {
  focal_length_ = 0;
  clear_has_focal_length();
}
inline double ProtoBufFrame_Camera_CameraType::focal_length() const {
  return focal_length_;
}
inline void ProtoBufFrame_Camera_CameraType::set_focal_length(double value) {
  set_has_focal_length();
  focal_length_ = value;
}

// -------------------------------------------------------------------

// ProtoBufFrame_Camera_CameraSettings

// optional double gain = 1;
inline bool ProtoBufFrame_Camera_CameraSettings::has_gain() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ProtoBufFrame_Camera_CameraSettings::set_has_gain() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ProtoBufFrame_Camera_CameraSettings::clear_has_gain() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ProtoBufFrame_Camera_CameraSettings::clear_gain() {
  gain_ = 0;
  clear_has_gain();
}
inline double ProtoBufFrame_Camera_CameraSettings::gain() const {
  return gain_;
}
inline void ProtoBufFrame_Camera_CameraSettings::set_gain(double value) {
  set_has_gain();
  gain_ = value;
}

// optional double brightness = 2;
inline bool ProtoBufFrame_Camera_CameraSettings::has_brightness() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ProtoBufFrame_Camera_CameraSettings::set_has_brightness() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ProtoBufFrame_Camera_CameraSettings::clear_has_brightness() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ProtoBufFrame_Camera_CameraSettings::clear_brightness() {
  brightness_ = 0;
  clear_has_brightness();
}
inline double ProtoBufFrame_Camera_CameraSettings::brightness() const {
  return brightness_;
}
inline void ProtoBufFrame_Camera_CameraSettings::set_brightness(double value) {
  set_has_brightness();
  brightness_ = value;
}

// optional double shutter = 3;
inline bool ProtoBufFrame_Camera_CameraSettings::has_shutter() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ProtoBufFrame_Camera_CameraSettings::set_has_shutter() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ProtoBufFrame_Camera_CameraSettings::clear_has_shutter() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ProtoBufFrame_Camera_CameraSettings::clear_shutter() {
  shutter_ = 0;
  clear_has_shutter();
}
inline double ProtoBufFrame_Camera_CameraSettings::shutter() const {
  return shutter_;
}
inline void ProtoBufFrame_Camera_CameraSettings::set_shutter(double value) {
  set_has_shutter();
  shutter_ = value;
}

// optional double white_balance = 4;
inline bool ProtoBufFrame_Camera_CameraSettings::has_white_balance() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ProtoBufFrame_Camera_CameraSettings::set_has_white_balance() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ProtoBufFrame_Camera_CameraSettings::clear_has_white_balance() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ProtoBufFrame_Camera_CameraSettings::clear_white_balance() {
  white_balance_ = 0;
  clear_has_white_balance();
}
inline double ProtoBufFrame_Camera_CameraSettings::white_balance() const {
  return white_balance_;
}
inline void ProtoBufFrame_Camera_CameraSettings::set_white_balance(double value) {
  set_has_white_balance();
  white_balance_ = value;
}

// optional double saturation = 5;
inline bool ProtoBufFrame_Camera_CameraSettings::has_saturation() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ProtoBufFrame_Camera_CameraSettings::set_has_saturation() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ProtoBufFrame_Camera_CameraSettings::clear_has_saturation() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ProtoBufFrame_Camera_CameraSettings::clear_saturation() {
  saturation_ = 0;
  clear_has_saturation();
}
inline double ProtoBufFrame_Camera_CameraSettings::saturation() const {
  return saturation_;
}
inline void ProtoBufFrame_Camera_CameraSettings::set_saturation(double value) {
  set_has_saturation();
  saturation_ = value;
}

// optional double contrast = 6;
inline bool ProtoBufFrame_Camera_CameraSettings::has_contrast() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ProtoBufFrame_Camera_CameraSettings::set_has_contrast() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ProtoBufFrame_Camera_CameraSettings::clear_has_contrast() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ProtoBufFrame_Camera_CameraSettings::clear_contrast() {
  contrast_ = 0;
  clear_has_contrast();
}
inline double ProtoBufFrame_Camera_CameraSettings::contrast() const {
  return contrast_;
}
inline void ProtoBufFrame_Camera_CameraSettings::set_contrast(double value) {
  set_has_contrast();
  contrast_ = value;
}

// optional double sharpness = 7;
inline bool ProtoBufFrame_Camera_CameraSettings::has_sharpness() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ProtoBufFrame_Camera_CameraSettings::set_has_sharpness() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ProtoBufFrame_Camera_CameraSettings::clear_has_sharpness() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ProtoBufFrame_Camera_CameraSettings::clear_sharpness() {
  sharpness_ = 0;
  clear_has_sharpness();
}
inline double ProtoBufFrame_Camera_CameraSettings::sharpness() const {
  return sharpness_;
}
inline void ProtoBufFrame_Camera_CameraSettings::set_sharpness(double value) {
  set_has_sharpness();
  sharpness_ = value;
}

// optional double hue = 8;
inline bool ProtoBufFrame_Camera_CameraSettings::has_hue() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ProtoBufFrame_Camera_CameraSettings::set_has_hue() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ProtoBufFrame_Camera_CameraSettings::clear_has_hue() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ProtoBufFrame_Camera_CameraSettings::clear_hue() {
  hue_ = 0;
  clear_has_hue();
}
inline double ProtoBufFrame_Camera_CameraSettings::hue() const {
  return hue_;
}
inline void ProtoBufFrame_Camera_CameraSettings::set_hue(double value) {
  set_has_hue();
  hue_ = value;
}

// optional double gamma = 9;
inline bool ProtoBufFrame_Camera_CameraSettings::has_gamma() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ProtoBufFrame_Camera_CameraSettings::set_has_gamma() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ProtoBufFrame_Camera_CameraSettings::clear_has_gamma() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ProtoBufFrame_Camera_CameraSettings::clear_gamma() {
  gamma_ = 0;
  clear_has_gamma();
}
inline double ProtoBufFrame_Camera_CameraSettings::gamma() const {
  return gamma_;
}
inline void ProtoBufFrame_Camera_CameraSettings::set_gamma(double value) {
  set_has_gamma();
  gamma_ = value;
}

// -------------------------------------------------------------------

// ProtoBufFrame_Camera

// required .protobuf.ProtoBufFrame.Camera.CameraType type = 1;
inline bool ProtoBufFrame_Camera::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ProtoBufFrame_Camera::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ProtoBufFrame_Camera::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ProtoBufFrame_Camera::clear_type() {
  if (type_ != NULL) type_->::protobuf::ProtoBufFrame_Camera_CameraType::Clear();
  clear_has_type();
}
inline const ::protobuf::ProtoBufFrame_Camera_CameraType& ProtoBufFrame_Camera::type() const {
  return type_ != NULL ? *type_ : *default_instance_->type_;
}
inline ::protobuf::ProtoBufFrame_Camera_CameraType* ProtoBufFrame_Camera::mutable_type() {
  set_has_type();
  if (type_ == NULL) type_ = new ::protobuf::ProtoBufFrame_Camera_CameraType;
  return type_;
}
inline ::protobuf::ProtoBufFrame_Camera_CameraType* ProtoBufFrame_Camera::release_type() {
  clear_has_type();
  ::protobuf::ProtoBufFrame_Camera_CameraType* temp = type_;
  type_ = NULL;
  return temp;
}

// required .protobuf.ImageData image_data = 2;
inline bool ProtoBufFrame_Camera::has_image_data() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ProtoBufFrame_Camera::set_has_image_data() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ProtoBufFrame_Camera::clear_has_image_data() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ProtoBufFrame_Camera::clear_image_data() {
  if (image_data_ != NULL) image_data_->::protobuf::ImageData::Clear();
  clear_has_image_data();
}
inline const ::protobuf::ImageData& ProtoBufFrame_Camera::image_data() const {
  return image_data_ != NULL ? *image_data_ : *default_instance_->image_data_;
}
inline ::protobuf::ImageData* ProtoBufFrame_Camera::mutable_image_data() {
  set_has_image_data();
  if (image_data_ == NULL) image_data_ = new ::protobuf::ImageData;
  return image_data_;
}
inline ::protobuf::ImageData* ProtoBufFrame_Camera::release_image_data() {
  clear_has_image_data();
  ::protobuf::ImageData* temp = image_data_;
  image_data_ = NULL;
  return temp;
}

// repeated .protobuf.ProtoBufFrame.Object objects = 3;
inline int ProtoBufFrame_Camera::objects_size() const {
  return objects_.size();
}
inline void ProtoBufFrame_Camera::clear_objects() {
  objects_.Clear();
}
inline const ::protobuf::ProtoBufFrame_Object& ProtoBufFrame_Camera::objects(int index) const {
  return objects_.Get(index);
}
inline ::protobuf::ProtoBufFrame_Object* ProtoBufFrame_Camera::mutable_objects(int index) {
  return objects_.Mutable(index);
}
inline ::protobuf::ProtoBufFrame_Object* ProtoBufFrame_Camera::add_objects() {
  return objects_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::protobuf::ProtoBufFrame_Object >&
ProtoBufFrame_Camera::objects() const {
  return objects_;
}
inline ::google::protobuf::RepeatedPtrField< ::protobuf::ProtoBufFrame_Object >*
ProtoBufFrame_Camera::mutable_objects() {
  return &objects_;
}

// optional .protobuf.ProtoBufFrame.Camera.CameraSettings settings = 4;
inline bool ProtoBufFrame_Camera::has_settings() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ProtoBufFrame_Camera::set_has_settings() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ProtoBufFrame_Camera::clear_has_settings() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ProtoBufFrame_Camera::clear_settings() {
  if (settings_ != NULL) settings_->::protobuf::ProtoBufFrame_Camera_CameraSettings::Clear();
  clear_has_settings();
}
inline const ::protobuf::ProtoBufFrame_Camera_CameraSettings& ProtoBufFrame_Camera::settings() const {
  return settings_ != NULL ? *settings_ : *default_instance_->settings_;
}
inline ::protobuf::ProtoBufFrame_Camera_CameraSettings* ProtoBufFrame_Camera::mutable_settings() {
  set_has_settings();
  if (settings_ == NULL) settings_ = new ::protobuf::ProtoBufFrame_Camera_CameraSettings;
  return settings_;
}
inline ::protobuf::ProtoBufFrame_Camera_CameraSettings* ProtoBufFrame_Camera::release_settings() {
  clear_has_settings();
  ::protobuf::ProtoBufFrame_Camera_CameraSettings* temp = settings_;
  settings_ = NULL;
  return temp;
}

// optional .protobuf.ProtoBufFrame.DataBlob team_data = 5;
inline bool ProtoBufFrame_Camera::has_team_data() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ProtoBufFrame_Camera::set_has_team_data() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ProtoBufFrame_Camera::clear_has_team_data() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ProtoBufFrame_Camera::clear_team_data() {
  if (team_data_ != NULL) team_data_->::protobuf::ProtoBufFrame_DataBlob::Clear();
  clear_has_team_data();
}
inline const ::protobuf::ProtoBufFrame_DataBlob& ProtoBufFrame_Camera::team_data() const {
  return team_data_ != NULL ? *team_data_ : *default_instance_->team_data_;
}
inline ::protobuf::ProtoBufFrame_DataBlob* ProtoBufFrame_Camera::mutable_team_data() {
  set_has_team_data();
  if (team_data_ == NULL) team_data_ = new ::protobuf::ProtoBufFrame_DataBlob;
  return team_data_;
}
inline ::protobuf::ProtoBufFrame_DataBlob* ProtoBufFrame_Camera::release_team_data() {
  clear_has_team_data();
  ::protobuf::ProtoBufFrame_DataBlob* temp = team_data_;
  team_data_ = NULL;
  return temp;
}

// optional .protobuf.Vector camera_position = 6;
inline bool ProtoBufFrame_Camera::has_camera_position() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ProtoBufFrame_Camera::set_has_camera_position() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ProtoBufFrame_Camera::clear_has_camera_position() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ProtoBufFrame_Camera::clear_camera_position() {
  if (camera_position_ != NULL) camera_position_->::protobuf::Vector::Clear();
  clear_has_camera_position();
}
inline const ::protobuf::Vector& ProtoBufFrame_Camera::camera_position() const {
  return camera_position_ != NULL ? *camera_position_ : *default_instance_->camera_position_;
}
inline ::protobuf::Vector* ProtoBufFrame_Camera::mutable_camera_position() {
  set_has_camera_position();
  if (camera_position_ == NULL) camera_position_ = new ::protobuf::Vector;
  return camera_position_;
}
inline ::protobuf::Vector* ProtoBufFrame_Camera::release_camera_position() {
  clear_has_camera_position();
  ::protobuf::Vector* temp = camera_position_;
  camera_position_ = NULL;
  return temp;
}

// optional .protobuf.Vector optical_axis = 7;
inline bool ProtoBufFrame_Camera::has_optical_axis() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ProtoBufFrame_Camera::set_has_optical_axis() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ProtoBufFrame_Camera::clear_has_optical_axis() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ProtoBufFrame_Camera::clear_optical_axis() {
  if (optical_axis_ != NULL) optical_axis_->::protobuf::Vector::Clear();
  clear_has_optical_axis();
}
inline const ::protobuf::Vector& ProtoBufFrame_Camera::optical_axis() const {
  return optical_axis_ != NULL ? *optical_axis_ : *default_instance_->optical_axis_;
}
inline ::protobuf::Vector* ProtoBufFrame_Camera::mutable_optical_axis() {
  set_has_optical_axis();
  if (optical_axis_ == NULL) optical_axis_ = new ::protobuf::Vector;
  return optical_axis_;
}
inline ::protobuf::Vector* ProtoBufFrame_Camera::release_optical_axis() {
  clear_has_optical_axis();
  ::protobuf::Vector* temp = optical_axis_;
  optical_axis_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// ProtoBufFrame

// optional int32 time = 1;
inline bool ProtoBufFrame::has_time() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ProtoBufFrame::set_has_time() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ProtoBufFrame::clear_has_time() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ProtoBufFrame::clear_time() {
  time_ = 0;
  clear_has_time();
}
inline ::google::protobuf::int32 ProtoBufFrame::time() const {
  return time_;
}
inline void ProtoBufFrame::set_time(::google::protobuf::int32 value) {
  set_has_time();
  time_ = value;
}

// optional int32 sequence_id = 2;
inline bool ProtoBufFrame::has_sequence_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ProtoBufFrame::set_has_sequence_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ProtoBufFrame::clear_has_sequence_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ProtoBufFrame::clear_sequence_id() {
  sequence_id_ = 0;
  clear_has_sequence_id();
}
inline ::google::protobuf::int32 ProtoBufFrame::sequence_id() const {
  return sequence_id_;
}
inline void ProtoBufFrame::set_sequence_id(::google::protobuf::int32 value) {
  set_has_sequence_id();
  sequence_id_ = value;
}

// optional string comment = 3;
inline bool ProtoBufFrame::has_comment() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ProtoBufFrame::set_has_comment() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ProtoBufFrame::clear_has_comment() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ProtoBufFrame::clear_comment() {
  if (comment_ != &::google::protobuf::internal::kEmptyString) {
    comment_->clear();
  }
  clear_has_comment();
}
inline const ::std::string& ProtoBufFrame::comment() const {
  return *comment_;
}
inline void ProtoBufFrame::set_comment(const ::std::string& value) {
  set_has_comment();
  if (comment_ == &::google::protobuf::internal::kEmptyString) {
    comment_ = new ::std::string;
  }
  comment_->assign(value);
}
inline void ProtoBufFrame::set_comment(const char* value) {
  set_has_comment();
  if (comment_ == &::google::protobuf::internal::kEmptyString) {
    comment_ = new ::std::string;
  }
  comment_->assign(value);
}
inline void ProtoBufFrame::set_comment(const char* value, size_t size) {
  set_has_comment();
  if (comment_ == &::google::protobuf::internal::kEmptyString) {
    comment_ = new ::std::string;
  }
  comment_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ProtoBufFrame::mutable_comment() {
  set_has_comment();
  if (comment_ == &::google::protobuf::internal::kEmptyString) {
    comment_ = new ::std::string;
  }
  return comment_;
}
inline ::std::string* ProtoBufFrame::release_comment() {
  clear_has_comment();
  if (comment_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = comment_;
    comment_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string capture_location = 4;
inline bool ProtoBufFrame::has_capture_location() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ProtoBufFrame::set_has_capture_location() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ProtoBufFrame::clear_has_capture_location() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ProtoBufFrame::clear_capture_location() {
  if (capture_location_ != &::google::protobuf::internal::kEmptyString) {
    capture_location_->clear();
  }
  clear_has_capture_location();
}
inline const ::std::string& ProtoBufFrame::capture_location() const {
  return *capture_location_;
}
inline void ProtoBufFrame::set_capture_location(const ::std::string& value) {
  set_has_capture_location();
  if (capture_location_ == &::google::protobuf::internal::kEmptyString) {
    capture_location_ = new ::std::string;
  }
  capture_location_->assign(value);
}
inline void ProtoBufFrame::set_capture_location(const char* value) {
  set_has_capture_location();
  if (capture_location_ == &::google::protobuf::internal::kEmptyString) {
    capture_location_ = new ::std::string;
  }
  capture_location_->assign(value);
}
inline void ProtoBufFrame::set_capture_location(const char* value, size_t size) {
  set_has_capture_location();
  if (capture_location_ == &::google::protobuf::internal::kEmptyString) {
    capture_location_ = new ::std::string;
  }
  capture_location_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ProtoBufFrame::mutable_capture_location() {
  set_has_capture_location();
  if (capture_location_ == &::google::protobuf::internal::kEmptyString) {
    capture_location_ = new ::std::string;
  }
  return capture_location_;
}
inline ::std::string* ProtoBufFrame::release_capture_location() {
  clear_has_capture_location();
  if (capture_location_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = capture_location_;
    capture_location_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional .protobuf.ProtoBufFrame.RobotData robot_data = 5;
inline bool ProtoBufFrame::has_robot_data() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ProtoBufFrame::set_has_robot_data() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ProtoBufFrame::clear_has_robot_data() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ProtoBufFrame::clear_robot_data() {
  if (robot_data_ != NULL) robot_data_->::protobuf::ProtoBufFrame_RobotData::Clear();
  clear_has_robot_data();
}
inline const ::protobuf::ProtoBufFrame_RobotData& ProtoBufFrame::robot_data() const {
  return robot_data_ != NULL ? *robot_data_ : *default_instance_->robot_data_;
}
inline ::protobuf::ProtoBufFrame_RobotData* ProtoBufFrame::mutable_robot_data() {
  set_has_robot_data();
  if (robot_data_ == NULL) robot_data_ = new ::protobuf::ProtoBufFrame_RobotData;
  return robot_data_;
}
inline ::protobuf::ProtoBufFrame_RobotData* ProtoBufFrame::release_robot_data() {
  clear_has_robot_data();
  ::protobuf::ProtoBufFrame_RobotData* temp = robot_data_;
  robot_data_ = NULL;
  return temp;
}

// repeated .protobuf.ProtoBufFrame.Camera camera = 6;
inline int ProtoBufFrame::camera_size() const {
  return camera_.size();
}
inline void ProtoBufFrame::clear_camera() {
  camera_.Clear();
}
inline const ::protobuf::ProtoBufFrame_Camera& ProtoBufFrame::camera(int index) const {
  return camera_.Get(index);
}
inline ::protobuf::ProtoBufFrame_Camera* ProtoBufFrame::mutable_camera(int index) {
  return camera_.Mutable(index);
}
inline ::protobuf::ProtoBufFrame_Camera* ProtoBufFrame::add_camera() {
  return camera_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::protobuf::ProtoBufFrame_Camera >&
ProtoBufFrame::camera() const {
  return camera_;
}
inline ::google::protobuf::RepeatedPtrField< ::protobuf::ProtoBufFrame_Camera >*
ProtoBufFrame::mutable_camera() {
  return &camera_;
}

// repeated .protobuf.ProtoBufFrame.Object merged_objects = 7;
inline int ProtoBufFrame::merged_objects_size() const {
  return merged_objects_.size();
}
inline void ProtoBufFrame::clear_merged_objects() {
  merged_objects_.Clear();
}
inline const ::protobuf::ProtoBufFrame_Object& ProtoBufFrame::merged_objects(int index) const {
  return merged_objects_.Get(index);
}
inline ::protobuf::ProtoBufFrame_Object* ProtoBufFrame::mutable_merged_objects(int index) {
  return merged_objects_.Mutable(index);
}
inline ::protobuf::ProtoBufFrame_Object* ProtoBufFrame::add_merged_objects() {
  return merged_objects_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::protobuf::ProtoBufFrame_Object >&
ProtoBufFrame::merged_objects() const {
  return merged_objects_;
}
inline ::google::protobuf::RepeatedPtrField< ::protobuf::ProtoBufFrame_Object >*
ProtoBufFrame::mutable_merged_objects() {
  return &merged_objects_;
}

// optional .protobuf.ProtoBufFrame.DataBlob team_data = 8;
inline bool ProtoBufFrame::has_team_data() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ProtoBufFrame::set_has_team_data() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ProtoBufFrame::clear_has_team_data() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ProtoBufFrame::clear_team_data() {
  if (team_data_ != NULL) team_data_->::protobuf::ProtoBufFrame_DataBlob::Clear();
  clear_has_team_data();
}
inline const ::protobuf::ProtoBufFrame_DataBlob& ProtoBufFrame::team_data() const {
  return team_data_ != NULL ? *team_data_ : *default_instance_->team_data_;
}
inline ::protobuf::ProtoBufFrame_DataBlob* ProtoBufFrame::mutable_team_data() {
  set_has_team_data();
  if (team_data_ == NULL) team_data_ = new ::protobuf::ProtoBufFrame_DataBlob;
  return team_data_;
}
inline ::protobuf::ProtoBufFrame_DataBlob* ProtoBufFrame::release_team_data() {
  clear_has_team_data();
  ::protobuf::ProtoBufFrame_DataBlob* temp = team_data_;
  team_data_ = NULL;
  return temp;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace protobuf

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_ProtoBufFrame_2eproto__INCLUDED
